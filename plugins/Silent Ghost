project/
├── main.py
├── config.py
├── requirements.txt
├── services/
│   └── database.py
├── handlers/
│   ├── file_save.py
│   └── video_request.py
├── utils/
│   ├── limits.py
│   └── reset_daily_limits.py
└── .env  # Optional for secrets

# main.py
from pyrogram import Client, filters
from config import API_ID, API_HASH, BOT_TOKEN

app = Client(
    "video_bot",
    api_id=API_ID,
    api_hash=API_HASH,
    bot_token=BOT_TOKEN,
    plugins={"root": "handlers"}
)

if __name__ == "__main__":
    print("Bot started...")
    app.run()

# config.py
import os

API_ID = int(os.getenv("API_ID", 123456))
API_HASH = os.getenv("API_HASH", "your_api_hash")
BOT_TOKEN = os.getenv("BOT_TOKEN", "your_bot_token")

DS_DB_URI = os.getenv("DS_DB_URI", "mongodb://localhost:27017")
DS_DB_NAME = os.getenv("DS_DB_NAME", "VideoBot")

DESI_CHANNEL = -1001234567890
VIDESI_CHANNEL = -1009876543210

FREE_DAILY_LIMIT = 10

# requirements.txt
pyrogram==2.0.106
motor
pymongo
python-dotenv
apscheduler

# utils/limits.py
import datetime
from config import FREE_DAILY_LIMIT
from services.database import db

async def check_and_increment(user_id):
    user = await db.get_user(user_id)
    if not user:
        await db.add_user(user_id, f"User{user_id}")
        return True

    today = datetime.datetime.utcnow().date()
    last_used = user.get("date")
    used = user.get("free_used", 0)

    if await db.has_premium_access(user_id):
        return True

    if last_used == str(today):
        if used >= FREE_DAILY_LIMIT:
            return False
        await db.set_free_used(user_id, used + 1)
    else:
        await db.set_free_used(user_id, 1)
        await db.set_date(user_id, str(today))

    return True

# utils/reset_daily_limits.py
import asyncio
import datetime
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from services.database import db

async def reset_limits():
    print("Resetting daily usage limits...")
    async for user in db.get_all_users():
        await db.set_free_used(user['id'], 0)
        await db.set_date(user['id'], str(datetime.datetime.utcnow().date()))
    print("Limits reset.")

async def start_scheduler():
    scheduler = AsyncIOScheduler()
    scheduler.add_job(reset_limits, "cron", hour=0, minute=0)  # Every midnight UTC
    scheduler.start()

# In main.py, optionally import this:
# from utils.reset_daily_limits import start_scheduler
# Inside __main__ block: await start_scheduler() before app.run()

# handlers/file_save.py
from pyrogram import Client, filters
from config import DESI_CHANNEL, VIDESI_CHANNEL
from services.database import db

@Client.on_message(filters.video & filters.chat(DESI_CHANNEL))
async def save_desi(_, message):
    await db.save_file(
        caption=message.caption or "",
        file_id=message.video.file_id,
        msg_id=message.id,
        file_size=message.video.file_size,
        tag="desi"
    )

@Client.on_message(filters.video & filters.chat(VIDESI_CHANNEL))
async def save_videsi(_, message):
    await db.save_file(
        caption=message.caption or "",
        file_id=message.video.file_id,
        msg_id=message.id,
        file_size=message.video.file_size,
        tag="videsi"
    )

# handlers/video_request.py
from pyrogram import Client, filters
from config import DESI_CHANNEL, VIDESI_CHANNEL
from services.database import db
from utils.limits import check_and_increment

@Client.on_message(filters.private & filters.text)
async def handle_request(bot, message):
    user_id = message.from_user.id
    text = message.text.lower()

    if "get video" in text:
        tag, channel = "desi", DESI_CHANNEL
    elif "videsi" in text:
        tag, channel = "videsi", VIDESI_CHANNEL
    else:
        return await message.reply("Invalid option.")

    allowed = await check_and_increment(user_id)
    if not allowed:
        return await message.reply("Daily limit reached. Upgrade to premium.")

    file = await db.random_file(tag)
    if not file:
        return await message.reply("No video found.")

    try:
        await bot.copy_message(
            chat_id=message.chat.id,
            from_chat_id=channel,
            message_id=file['msg_id']
        )
    except Exception as e:
        await message.reply("Failed to send video.")
